#!/usr/bin/env python
# -*- coding: utf-8 -*-

# from ROS packages
import message_filters
from geometry_msgs.msg import PointStamed
from nav_msgs.msg import Odometry
from moving_object_detector.msg import MovingObjectArray
from moving_object_detector.msg import ExpResult
import ros_numpy
import rospy

# from non-ROS
import numpy

class SimulationExpResultCalc:
    def __init__(self):
        rospy.init_node('simulation_exp_result_calc')

        self._pub = rospy.Publisher('center_converted', geometry_msgs.msg.PointStamped, queue_size=30)
        self._pub = rospy.Publisher('center', geometry_msgs.msg.PointStamped, queue_size=30)
        self._pub = rospy.Publisher('center_converted', geometry_msgs.msg.PointStamped, queue_size=30)
        self._truth_odom_sub = message_filters.Subscriber('odom', Odometry)
        self._truth_center_sub = message_filters.Subscriber('center', PointStamped)
        self._estimated_sub = message_filters.Subscriber('moving_objects', MovingObjectArray)

        self._sync = message_filters.ApproximateTimeSynchronizer([self._truth_center_sub, self._truth_odom_sub, self._estimated_sub], 20, 0.04)
        self._sync.registerCallback(self.callback)

    def callback(self, truth_pos, truth_odom, est_obj_arr):
        msg = ExpResult()
        msg.truth_stamp = truth_pos.header.stamp
        msg.estimated_stamp = est_obj_arr.header.stamp

        # Find nearest object to truth value

        truth_pos = ros_numpy.numpify
        vel_truth = ros_numpy.numpify(truth_odom.twist.twist.linear)


        if len(est_obj_arr.moving_object_array) <= 0:
            msg.detected = False
        else:
            msg.detected = True
            for est_obj in est_moving_objs:
                est_pos = ros_numpy.numpify(est_obj.center)
                pos_err = numpy.linalg.norm(est_pos - truth_pos)
                if 'min_pos_err' in locals(): 
                    if pos_err < min_pos_err:
                        min_pos_err = pos_err
                else:
                    min_pos_err = pos_err

                est_vel = ros_numpy.numpify(est_obj.velocity)
                vel_err = numpy.linalg.norm(est_vel - vel)
                if 'min_vel_err' in locals(): 
                    if vel_err < min_vel_err:
                        min_vel_err = vel_err
                else:
                    min_vel_err = vel_err
            
        vel_estimated = ros_numpy.numpify(estimated.)
        vel_err = truth_odom.twist.twist
      

if __name__ == '__main__':
    conveter = PointFrameConverter()
    rospy.spin()



import message_filters
from sensor_msgs.msg import Image, CameraInfo

def callback(image, camera_info):
  # Solve all of perception here...

image_sub = message_filters.Subscriber('image', Image)
info_sub = message_filters.Subscriber('camera_info', CameraInfo)

ts = message_filters.TimeSynchronizer([image_sub, info_sub], 10)
ts.registerCallback(callback)
rospy.spin()
