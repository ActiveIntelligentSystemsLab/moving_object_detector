#!/usr/bin/env python
# -*- coding: utf-8 -*-

# from ROS packages
import message_filters
from geometry_msgs.msg import PointStamped
from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Vector3Stamped
from nav_msgs.msg import Odometry
from moving_object_detector.msg import MovingObjectArray
from moving_object_detector.msg import ExpResult
import ros_numpy
import rospy
import tf2_geometry_msgs
import tf2_ros

# from non-ROS
import numpy

class SimulationExpResultCalc:
    def __init__(self):
        rospy.init_node('simulation_exp_result_calc')
        
        self._tf_buffer = tf2_ros.Buffer()
        self._listener = tf2_ros.TransformListener(self._tf_buffer)

        self._pub = rospy.Publisher('exp_result', ExpResult, queue_size=30)
        self._truth_odom_sub = message_filters.Subscriber('odom', Odometry)
        self._truth_center_sub = message_filters.Subscriber('center', PointStamped)
        self._estimated_sub = message_filters.Subscriber('moving_objects', MovingObjectArray)

        self._sync = message_filters.ApproximateTimeSynchronizer([self._truth_center_sub, self._truth_odom_sub, self._estimated_sub], 20, 0.04)
        self._sync.registerCallback(self.callback)

    def callback(self, truth_pos, truth_odom, est_obj_arr):
        result = ExpResult()
        result.odom_stamp = truth_pos.header.stamp
        result.center_stamp = truth_odom.header.stamp
        result.estimated_stamp = est_obj_arr.header.stamp
        
        if len(est_obj_arr.moving_object_array) <= 0:
            result.detected = False
        else:
            result.detected = True
            
            truth_vel = self.odometry_to_velocity(truth_odom)
            try:
                truth_pos = self._tf_buffer.transform(truth_pos, est_obj_arr.header.frame_id)
                truth_vel = self._tf_buffer.transform(truth_vel, est_obj_arr.header.frame_id)
            except(tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                rospy.loginfo("TF is not found")
                return
            
            self.calculate_error(truth_pos, truth_vel, est_obj_arr, result)

        self._pub.publish(result)
        
    def odometry_to_velocity(self, odometry):
        velocity = Vector3Stamped()
        velocity.header.stamp = odometry.header.stamp
        velocity.header.frame_id = odometry.child_frame_id
        velocity.vector = odometry.twist.twist.linear
        return velocity
    
    def calculate_error(self, truth_pos, truth_vel, est_obj_arr, exp_result):
        truth_pos = ros_numpy.numpify(truth_pos.point)
        truth_vel = ros_numpy.numpify(truth_vel.vector)
        
        min_pos_err = None
        for est_obj in est_obj_arr.moving_object_array:
            est_pos = ros_numpy.numpify(est_obj.center)
            pos_err = est_pos - truth_pos
            if min_pos_err == None or numpy.linalg.norm(pos_err) < numpy.linalg.norm(min_pos_err):
                min_pos_err = pos_err
                est_vel = ros_numpy.numpify(est_obj.velocity)
                vel_err = est_vel - truth_vel
        
        exp_result.velcotiy_magnitude_error = numpy.linalg.norm(truth_vel) - numpy.linalg.norm(est_vel)
        exp_result.velocity_angle_error = numpy.math.arccos(numpy.dot(est_vel, truth_vel) / (numpy.linalg.norm(est_vel) * numpy.linalg.norm(truth_vel)))
        exp_result.velocity_error = ros_numpy.msgify(Vector3, vel_err)
        exp_result.position_error = ros_numpy.msgify(Vector3, min_pos_err)

if __name__ == '__main__':
    result_calc = SimulationExpResultCalc()
    rospy.spin()
