#!/usr/bin/env python
# -*- coding: utf-8 -*-

# from ROS packages
import message_filters
from geometry_msgs.msg import PointStamped
from nav_msgs.msg import Odometry
from moving_object_detector.msg import MovingObjectArray
from moving_object_detector.msg import ExpResult
import ros_numpy
import rospy
import tf2_geometry_msgs
import tf2_ros

# from non-ROS
import numpy

class SimulationExpResultCalc:
    def __init__(self):
        rospy.init_node('simulation_exp_result_calc')
        
        self._tf_buffer = tf2_ros.Buffer()
        self._listener = tf2_ros.TransformListener(self._tf_buffer)

        self._pub = rospy.Publisher('exp_result', ExpResult, queue_size=30)
        self._truth_odom_sub = message_filters.Subscriber('odom', Odometry)
        self._truth_center_sub = message_filters.Subscriber('center', PointStamped)
        self._estimated_sub = message_filters.Subscriber('moving_objects', MovingObjectArray)

        self._sync = message_filters.ApproximateTimeSynchronizer([self._truth_center_sub, self._truth_odom_sub, self._estimated_sub], 20, 0.04)
        self._sync.registerCallback(self.callback)

    def callback(self, truth_pos, truth_odom, est_obj_arr):
        msg = ExpResult()
        msg.odom_stamp = truth_pos.header.stamp
        msg.center_stamp = truth_odom.header.stamp
        msg.estimated_stamp = est_obj_arr.header.stamp
        
        if len(est_obj_arr.moving_object_array) <= 0:
            msg.detected = False
            msg.pos_err = -1.0
            msg.vel_err = -1.0
        else:
            msg.detected = True
            
            truth_vel = self.odometry_to_velocity(truth_odom)
            try:
                truth_pos = self._tf_buffer.transform(truth_pos, est_obj_arr.header.frame_id)
                truth_vel = self._tf_buffer.transform(truth_vel, est_obj_arr.header.frame_id)
            except(tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                rospy.loginfo("TF is not found")
                return
            
            self.calculate_error(truth_pos, truth_vel, est_obj_arr, msg)

        self._pub.publish(msg)
        
    def odometry_to_velocity(self, odometry):
        velocity = PointStamped()
        velocity.header.stamp = odometry.header.stamp
        velocity.header.frame_id = odometry.child_frame_id
        velocity.point.x = odometry.twist.twist.linear.x
        velocity.point.y = odometry.twist.twist.linear.y
        velocity.point.z = odometry.twist.twist.linear.z
        return velocity
    
    def calculate_error(self, truth_pos, truth_vel, est_obj_arr, exp_result):
        truth_pos = ros_numpy.numpify(truth_pos.point)
        truth_vel = ros_numpy.numpify(truth_vel.point)
        
        min_pos_err = None
        for est_obj in est_obj_arr.moving_object_array:
            est_pos = ros_numpy.numpify(est_obj.center)
            pos_err = numpy.linalg.norm(est_pos - truth_pos)
            if min_pos_err == None or pos_err < min_pos_err:
                min_pos_err = pos_err
                min_est_vel = ros_numpy.numpify(est_obj.velocity)
                vel_err = numpy.linalg.norm(min_est_vel - truth_vel)
                
        exp_result.pos_err = min_pos_err
        exp_result.vel_err = vel_err
        
      
if __name__ == '__main__':
    result_calc = SimulationExpResultCalc()
    rospy.spin()
